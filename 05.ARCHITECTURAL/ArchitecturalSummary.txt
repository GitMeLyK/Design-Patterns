
Architectural Patterns

	Premesessa 

		Cos’è un pattern architetturale
		Generalmente viene definito come “una soluzione generale e riutilizzabile per un problema 
		comune presente all’interno di un particolare contesto”. 
		In sostanza un pattern definisce lo scheletro che dovrà avere il software, 
		quali servizi dovranno entrare in gioco, le parti coinvolte e la logica di interazione 
		tra di esse.

		Simili ai design pattern ma applicati ad un contesto più ampio, i pattern architetturali 
		sono fondamentali per il design di un enterprise software. 
		Svolgono innanzitutto un ruolo di comunicazione tra gli stakeholders, ovvero i protagonisti 
		del progetto, offrendo un’astrazione comune del sistema. 
		I pattern offrono una base per la mutua comprensione, negoziazione e consenso, 
		senza che sia richiesta conoscenza informatica dettagliata.

		Un’architettura inoltre definisce l’organizzazione strutturale che dovrà essere rispettata, 
		e potrà essere poi utilizzata come metro di valutazione del progresso del progetto. 
		Sapendo esattamente quale aspetto dovrà avere il prodotto finale, sarà anche più semplice 
		capire se ci si sta allontanando dai confini prefissati, ed eventualmente aggiustare il tiro.

		Essa facilita inoltre la gestione del cambiamento, quando dovesse essere necessario. 
		Conoscendo la struttura logica del progetto, è più facile individuare i punti dove andare 
		ad agire e prevedere in che modo le diverse parti saranno influenzate dall’evoluzione del 
		sistema.

		Ultimo, ma non per importanza, assicura una maggiore robustezza del sistema rispetto ad 
		altre possibili scelte architetturali pensate da zero. 
		Essendo un modello studiato e testato, infatti, fornisce la soluzione ottimale per un 
		problema o un’intera categoria di problemi.


	
	---- ---- ---- ----
	- Design

	Design Premessa.:
		Nel ciclo di vita del software si può dire che sia la fase antecedente alla definizione 
		finale dell’architettura. In un certo senso è la prima fase da affrontare: non a caso 
		si parla di DESIGN, non architecture vere e proprie. 
		Nel gruppo Design appunto abbiamo inserito di proposito Design che vuole significare che
		non sono metodologie applicative di architetture da implementare ma studi di modellazione
		infrastrutturali o, ancor meno, di codice: è quindi totalmente indipendente sia dalle 
		tecnologie sia dai pattern, perlomeno nelle sue prime fasi.

	Layered. 

		Quando utilizzare questo Pattern e scopi.:
	
			Probabilmente il più conosciuto, il layered è un pattern che, come dice la parola, 
			è organizzato a livelli. 
			Anche se non esiste un numero predefinito di livelli, i più utilizzati sono 5:
				livello di presentazione
				livello applicativo
				livello di business o di dominio
				livello di persistenza o di accesso ai dati
				livello del database
			Ogni livello fornisce un’astrazione per quello successivo, e ha una sua 
			“responsabilità” da gestire. 
			Generalmente viene usato per applicazioni desktop e e-commerce. 
			La maggior parte degli sviluppatori ha familiarità con questo livello ed è quindi 
			più immediato da mettere in pratica, ma l’applicazione risultante è monolitica 
			e difficile da eventualmente dividere in più parti.
			Parliamo comunque di una soluzione per software di medio grande dimensioni, e non
			è consigliato per piccole soluzioni.

	Client-server. 

		Quando utilizzare questo Pattern e scopi.:
	
			Anch’esso tra i più conosciuti, è composto da due parti: client e server. 
			La sua logica va di pari passo con l’idea delle applicazioni online. 
			Il server è infatti quello che fornisce i contenuti e i servizi a più client, 
			e resta in attesa delle loro richieste. Questo tipo di architettura è un’evoluzione 
			della condivisione semplice delle risorse: il server, infatti, è in grado di soddisfare 
			le richieste di più client e gestisce gli accessi per evitare conflitti.

	Master-slave. 

		Quando utilizzare questo Pattern e scopi.:

			Un altro pattern con due parti, ma molto diverso dal precedente. 
			Il master-slave viene generalmente utilizzato in sistemi che richiedono 
			delle computazioni significative. 
			Una componente eletta master distribuisce il lavoro tra degli slave 
			identici tra loro, ottiene i singoli risultati e li utilizza per 
			fornire quello finale.
			Il modello Master-Slave viene spesso utilizzato per applicazioni 
			multithread in cui è necessario risolvere molte istanze dello stesso problema. 
			(Problema del commesso viaggiatore, ad esempio.) 
			Il master crea e lancia slave per risolvere queste istanze in "parallelo". 
			Quando tutti gli slave hanno finito, il master raccoglie i risultati.

	Pipe-filter. 

		Quando utilizzare questo Pattern e scopi.:
	
			Mai sentito parlare di pipeline? Dietro di essa c’è l’idea di questo pattern. 
			I sistemi costruiti seguendo le sue specifiche producono e processano stream di 
			dati. I dati vengono manipolati tramite degli step, che sono inclusi in dei filtri. 
			In essi avviene la modifica e alterazione dei dati. 
			Le pipes, invece, sono responsabili dello spostamento delle informazioni. 
			I servizi di streaming utilizzano questo pattern, in particolare per buffering 
			e sincronizzazione. 
			Altri esempi? Il compilatore: il codice scritto dal programmatore deve superare 
			l’analisi lessicale, il parsing, l’analisi semantica e infine la generazione 
			in linguaggio macchina.

	Peer-to-peer. 

		Quando utilizzare questo Pattern e scopi.:
	
			Non si può che associarlo immediatamente ai torrent, e in generale al file-sharing. 
			Questo pattern prevede la presenza di entità considerate tutte uguali (peer), che 
			possono agire alternativamente da client o da server, cambiando in maniera dinamica. 
			Contrariamente al broker, in questo caso non c’è nessuna componente che si erge 
			alla gestione della comunicazione.

	Interceptor

		Quando utilizzare questo Pattern e scopi.:

			Nel campo dello sviluppo software, un modello intercettore è un modello di progettazione 
			software che viene utilizzato quando i sistemi software o i framework vogliono offrire 
			un modo per cambiare, o aumentare, il loro solito ciclo di elaborazione. 
			Ad esempio, una sequenza di elaborazione tipica (semplificata) per un server Web 
			consiste nel ricevere un URI dal browser, mapparlo a un file su disco, aprire il file 
			e inviarne il contenuto al browser. Ognuno di questi passaggi potrebbe essere sostituito 
			o modificato, ad esempio sostituendo il modo in cui gli URI sono mappati ai nomi dei 
			file o inserendo un nuovo passaggio che elabora il contenuto dei file.

	Event-source. 

		Quando utilizzare questo Pattern e scopi.:
	
			Questo pattern viene utilizzato nei sistemi che utilizzano gli eventi. 
			Le componenti fondamentali sono l’event source, l’event listener, il canale di 
			comunicazione e l’event bus. 
			I canali rappresentano il luogo in cui gli eventi, o messaggi, vengono pubblicati, 
			e sono inseriti all’interno del bus degli eventi. 
			Alle estremità troviamo la source, ovvero l’entità che genera gli eventi pubblicando 
			sul canale, e il listener, che effettuano il subscribing ad un canale e vengono 
			notificati quando c’è un nuovo messaggio sul canale. 
			Anche in questo caso parliamo di un pattern fortemente improntato alla comunicazione 
			tra entità loosely-coupled.
			E' presente poi lo steso odello di progettazione impiantanto in un sistema Cloud qual'è
			Azure di microsoft con un esempio base riportato.

	Broker. 

		Quando utilizzare questo Pattern e scopi.:
	
			Questo pattern è utilizzato nei sistemi distribuiti, dove le componenti sono 
			disaccoppiate. 
			La comunicazione tra le parti è ovviamente remota, e per gestirla c’è necessità 
			di un’entità che coordini lo scambio di messaggi. 
			Il broker fa proprio questo, ponendosi in mezzo alle entità. 
			Può essere pensato come un client-server in cui però ogni entità espone dei 
			servizi e ognuna di esse può richiederne, e la loro comunicazione è mediata da 
			un’entità centrale. I middleware, per offrire il loro servizio, hanno al loro 
			interno un message broker.


	Publish-Subscribe. 

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come modello per organizzare il sistema in componenti che interagiscono 
			scambiandosi la notifica di eventi in modo asincrono tra due tipi di attore il Publisher
			e il Subscriber. Il primo notifica i messaggi a un sistema che smista e notifica questi
			ultimi a tutti i sottoscrittori a questi tipi di handle di notifica.
			Questo modello di progetazione fa anche parte dell'insieme dei pattern per sistemi 
			distribuiti in versione enterprise e su collocazioni cloud.:
			Riporto di seguito un link che rimanda ad un set completo di questi pattern tra cui alcuni
			li abbiamo in questo Lab compreso questo.
			*  Cloud Design Patterns : https://learn.microsoft.com/en-us/azure/architecture/patterns/


	DDD (Domain Driven Design)

		Quando utilizzare questo Pattern e scopi.:

			Domain-driven design (DDD) è un approccio dello sviluppo del software che risolve problemi 
			complessi connettendo l'implementazione ad un modello in evoluzione. 
			Le premesse del domain-driven sono le seguenti:
				- Puntare il focus primario del progetto sui domini delle entità e la loro logica.
				- Basare il design sulle entità di dominio.
				- Iniziare una creativa collaborazione tra tecnici ed esperti di dominio per 
				  definire in maniera iterativa un modello concettuale che possa essere applicato 
				  ai particolari problemi del caso.
			Il DDD è da considerarsi un approccio ad alto (quasi altissimo) livello e di tipo 
			top-down: sebbene sia fortemente condizionato dai principi della programmazione a 
			oggetti, è in realtà applicabile a qualunque modello di sviluppo e, anzi, si è poi 
			consolidato come approccio propedeutico per la programmazione orientata ai servizi (SOP).
			Essendo un approccio di alto livello e trasparente dalla scelte tecnologiche, è importante 
			che tutto il team che collabora nella fase di DDD capisca che l’obiettivo è focalizzare lo 
			sviluppo del software non sulla scelta tecnologica, ma sul business che deve erogare il software.
			Il business è il dominio: ecco perché domain-driven design.
			Nota.: Uno degli aspetti fondamentali di questo design è che è fonte di ispirazione e sviluppo
			per la realizzazione dei microservizi ditribuiti o in cloud.

	TDD (Test Driven Development)

		Quando utilizzare questo Pattern e scopi.:

			In informatica, nello sviluppo software, il test-driven development (abbreviato in TDD), 
			in italiano sviluppo guidato dai test[1] o sviluppo guidato dalle verifich è un modello 
			di sviluppo del software che prevede che la stesura dei test automatici avvenga prima di 
			quella del software che deve essere sottoposto a test, e che lo sviluppo del software 
			applicativo sia orientato esclusivamente all'obiettivo di passare i test automatici 
			precedentemente predisposti.
			Più in dettaglio, il TDD prevede la ripetizione di un breve ciclo di sviluppo in tre fasi, 
			detto "ciclo TDD". Nella prima fase (detta "fase rossa"), il programmatore scrive un test 
			automatico per la nuova funzione da sviluppare, che deve fallire in quanto la funzione non 
			è stata ancora realizzata. Nella seconda fase (detta "fase verde"), il programmatore sviluppa 
			la quantità minima di codice necessaria per passare il test. 
			Nella terza fase (detta "fase grigia" o di refactoring), il programmatore esegue il refactoring 
			del codice per adeguarlo a determinati standard di qualità.

	--- --- --- ----
	- Logic

	FrontController

		Quando utilizzare questo Pattern e scopi.:

			Il modello di progettazione del software del controller frontale è elencato 
			in diversi cataloghi di modelli e correlato alla progettazione di applicazioni Web. 
			È "un controller che gestisce tutte le richieste di un sito Web", che è una struttura 
			utile per gli sviluppatori di applicazioni Web per ottenere flessibilità e 
			riutilizzo senza ridondanza del codice. Gli attori coinvolti sono 
			Controllers Helpers Dispatchers Viste

	Model-View-Controller. (MVC) 

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come MVC, è il pattern maggiormente utilizzato soprattutto nelle applicazioni 
			e nei framework web. Tra i primi ad essere insegnati in ambienti accademici, 
			è un pattern che racchiude la logica delle applicazioni interattive e consente 
			di gestirle al meglio. Nell’MVC i protagonisti sono tre: il model, la view e 
			il controller. Il primo contiene le funzionalità e gestisce i dati, definendo gli 
			algoritmi e le funzioni che descrivono la logica del programma. La view rappresenta 
			la parte visiva, ed è con essa che si interfaccia l’utente. In un buon design, essa 
			dovrebbe essere il più possibile agnostica riguardo il model. Infine, il controller 
			si pone tra i due, da una parte gestendo l’input dell’utente e dall’altro fornendo le 
			informazioni necessarie al modello. Se seguito adeguatamente, permette una totale 
			distinzione tra le parti, che possono essere riutilizzate, modificate, sostituite 
			senza incidere sulle altre.

	Model-View-ViewModel. (MVVM) 

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come MVVM, è il pattern maggiormente utilizzato soprattutto nelle applicazioni 
			.net che fanno uso dell'ormai noto WPF basato su linguaggio XAML che presenta per applicazioni
			realtime su desktop o mobile un modello di progettazione basato sull'innesto tra la logica
			applicativa e quella della vista e della sua organizzazione.
			Model–view–viewmodel (MVVM) è un modello architetturale software che facilita la 
			separazione dello sviluppo dell'interfaccia utente grafica (la vista) – 
			sia tramite un linguaggio di markup o codice GUI – dallo sviluppo della logica di 
			business o della logica di back-end (il modello) in modo che la vista non dipenda 
			da alcuna piattaforma di modello specifica. Il viewmodel di MVVM è un convertitore 
			di valori, il che significa che il viewmodel è responsabile dell'esposizione 
			(conversione) degli oggetti dati dal modello in modo tale che gli oggetti siano 
			facilmente gestiti e presentati. A questo proposito, il viewmodel è più un modello 
			che una vista e gestisce la maggior parte se non tutta la logica di visualizzazione 
			della vista. 
			Il viewmodel può implementare un modello di mediazione, organizzando l'accesso alla 
			logica di back-end attorno all'insieme di casi d'uso supportati dalla vista.

	Model-View-Presentation. (MVP) 

		Quando utilizzare questo Pattern e scopi.:
	
			Model-view-presenter (MVP) è una derivazione del modello architettonico model-view-controller 
			(MVC) e viene utilizzato principalmente per la creazione di interfacce utente.
			In MVP, il presentatore assume la funzionalità di "intermediario". 
			In MVP, tutta la logica di presentazione viene inviata al relatore.

	Model 2 (JSP)

		Quando utilizzare questo Pattern e scopi.:

			JSP Model 2 è un modello di progettazione complesso utilizzato nella progettazione di 
			applicazioni Web Java che separa la visualizzazione del contenuto dalla logica utilizzata 
			per ottenere e manipolare il contenuto. Poiché il modello 2 determina una separazione 
			tra logica e visualizzazione, di solito è associato al paradigma modello-vista-controller (MVC). 
			Mentre la forma esatta del "Modello" MVC non è mai stata specificata dal progetto del Modello 2, 
			un certo numero di pubblicazioni consiglia un livello formalizzato per contenere il codice 
			del Modello MVC. I BluePrint Java, ad esempio, originariamente consigliavano di utilizzare 
			EJB per incapsulare il modello MVC.
			In un'applicazione Model 2, le richieste provenienti dal browser client vengono passate 
			al controller. Il controller esegue qualsiasi logica necessaria per ottenere il contenuto 
			corretto per la visualizzazione. Quindi inserisce il contenuto nella richiesta (comunemente 
			sotto forma di JavaBean o POJO) e decide a quale vista passerà la richiesta. La vista 
			esegue quindi il rendering del contenuto passato dal controller.
			Il modello 2 è consigliato per applicazioni di medie e grandi dimensioni.

	Action-Domain-Responder. (ADR) 

		Quando utilizzare questo Pattern e scopi.:
	
			Action-domain-responder (ADR) è un modello architetturale software proposto da 
			Paul M. Jones[1] come perfezionamento di Model-view-controller (MVC) più adatto 
			per le applicazioni web. ADR è stato concepito per abbinare il flusso di 
			richiesta-risposta delle comunicazioni HTTP più da vicino rispetto a MVC, 
			originariamente progettato per applicazioni software desktop. 
			Simile a MVC, il modello è diviso in tre parti.

	Naked Objects

		Quando utilizzare questo Pattern e scopi.:
	
			 Un modello architettonico utilizzato nell'ingegneria del software diverco da MVC. 
			 È definito da tre principi:
			 Tutta la logica di business deve essere incapsulata negli oggetti di dominio. 
				- Questo principio non è unico per gli oggetti nuked; è un forte impegno per l'incapsulamento.
				- L'interfaccia utente deve essere una rappresentazione diretta degli oggetti di 
				  dominio, con tutte le azioni utente costituite dalla creazione, dal recupero o 
			      dal richiamo di metodi sugli oggetti di dominio. 
			      Questo principio non è unico per gli oggetti naked: è un'interpretazione di 
			      un'interfaccia utente orientata agli oggetti.
			 La caratteristica innovativa del modello di oggetto nudo nasce combinando 
			 il 1 ° e il 2 ° principio in un 3 ° principio:
				- L'interfaccia utente è creata in modo completamente automatico a partire 
				  dalle definizioni degli oggetti di dominio. Questo può essere fatto usando 
				  la riflessione o la generazione di codice sorgente.
			 Il modello degli oggetti nudi è stato descritto per la prima volta formalmente 
			 nella tesi di dottorato di Richard Pawson che include l'indagine di antecedenti 
			 e ispirazioni per il modello, tra cui, ad esempio, l'interfaccia utente morphic.
			 E' un framework open source completo ad aver implementato il pattern è stato 
			 denominato Naked Objects. 
			 Nel 2021, Pawson ha annunciato di aver successivamente applicato lo stesso 
			 modello al paradigma di programmazione funzionale, in alternativa al paradigma 
			 di programmazione orientata agli oggetti, creando una variante 
			 del framework Naked Objects chiamata Naked Functions.

	Specification

		Quando utilizzare questo Pattern e scopi.:

			Nella programmazione informatica, il modello di specifica è un particolare modello di progettazione software, 
			in base al quale le regole di business possono essere ricombinate concatenando le regole di business utilizzando la 
			logica booleana. 
			Il modello viene spesso utilizzato nel contesto della progettazione basata sul dominio.
			Un modello di specifica delinea una regola di business che può essere combinata con altre regole di 
			business. 
			In questo modello, un'unità di logica di business eredita la propria funzionalità dalla classe 
			Composite Specification dell'aggregato astratto. 
			La classe Composite Specification dispone di una funzione denominata IsSatisfiedBy che restituisce 
			un valore booleano. Dopo l'istanziazione, la specifica viene "concatenata" con altre specifiche, 
			rendendo le nuove specifiche facilmente manutenibili, ma altamente personalizzabili. 
			Inoltre, al momento dell'istanza, la logica di business può, attraverso l'invocazione del metodo 
			o l'inversione del controllo, avere il suo stato alterato al fine di diventare un delegato di altre 
			classi come un repository di persistenza.
			Come conseguenza dell'esecuzione della composizione runtime della logica di business/dominio di alto 
			livello, il modello Specification è uno strumento utile per convertire i criteri di ricerca utente 
			ad-hoc in logica di basso livello da elaborare dai repository.
			Poiché una specifica è un incapsulamento della logica in una forma riutilizzabile, è molto 
			semplice eseguire test approfonditi e, se utilizzata in questo contesto, è anche un'implementazione 
			del modello di oggetti umili.


	Entity-Component-System. (ECS) 

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come ECS, è il pattern maggiormente utilizzato soprattutto nelle applicazioni 

	
	--- --- --- ----
	- Service

	Message Broker

		Quando utilizzare questo Pattern e scopi.:

			Un broker di messaggi (noto anche come broker di integrazione o motore di interfaccia) 
			è un modulo di programma per computer intermedio che traduce un messaggio dal protocollo 
			di messaggistica formale del mittente al protocollo di messaggistica formale del 
			destinatario. I broker di messaggi sono elementi nelle reti di telecomunicazioni o 
			di computer in cui le applicazioni software comunicano scambiando messaggi formalmente 
			definiti. I broker di messaggi sono un elemento costitutivo del middleware orientato ai 
			messaggi (MOM), ma in genere non sostituiscono il middleware tradizionale come MOM e RPC.
			Un broker di messaggi è un modello architetturale per la convalida, la trasformazione e il 
			routing dei messaggi. Media la comunicazione tra le applicazioni, riducendo al minimo la 
			consapevolezza reciproca che le applicazioni dovrebbero avere l'una dell'altra per poter 
			scambiare messaggi, implementando efficacemente il disaccoppiamento.
			Lo scopo principale di un broker è quello di prendere i messaggi in arrivo dalle 
			applicazioni ed eseguire alcune azioni su di essi. I broker di messaggi possono 
			disaccoppiare gli endpoint, soddisfare specifici requisiti non funzionali e facilitare 
			il riutilizzo delle funzioni intermedie. Ad esempio, un broker di messaggi può essere 
			utilizzato per gestire una coda di carichi di lavoro o una coda di messaggi per più 
			destinatari, fornendo spazio di archiviazione affidabile, recapito dei messaggi garantito 
			e forse gestione delle transazioni.
			I seguenti rappresentano altri esempi di azioni che potrebbero essere gestite dal broker:
				Instradare i messaggi a una o più destinazioni
				Trasformare i messaggi in una rappresentazione alternativa
				Eseguire l'aggregazione dei messaggi, scomponendo i messaggi in più messaggi e 
				 inviandoli alla loro destinazione, quindi ricomponendo le risposte in un unico 
				 messaggio per tornare all'utente
				Interagire con un repository esterno per aumentare un messaggio o archiviarlo
				Richiamare i servizi Web per recuperare i dati
				Rispondere a eventi o errori
				Fornire contenuto e routing dei messaggi basato su argomenti utilizzando il 
				modello di pubblicazione-sottoscrizione
			I broker di messaggi si basano generalmente su una delle due architetture fondamentali: 
					hub-and-spoke e bus di messaggi. 
					Nel primo, un server centrale funge da meccanismo che fornisce servizi di 
					integrazione, mentre con il secondo, il broker di messaggi è una dorsale 
					di comunicazione o un servizio distribuito che agisce sul bus. 
			Inoltre, è possibile utilizzare un approccio multi-hub più scalabile per integrare 
			più broker.
			** Si noti che il modello di broker di messaggi descritto in questo esempio in allegato
			è per la soluzione all'interno del contesto del processo e non descrive 
			l'intermediazione/routing dei messaggi tra i sistemi distribuiti. 
			Per tale scalabilità di sistemi, abbiamo già broker di messaggi aziendali, come Kafka, 
			coda del bus di servizio di Azure e così via.
			** Nell'esempio principalmente per il Message Pattern viene introdotto il Message Broker
			che è fulcro di uno dei modelli di progettazione per un sistema enterprise di infrastruttura
			nella rete orientata ai microservizi e alla loro comunicazione sincrona e asincrona.
			In questo esempio introduciamo appunto questo modello di progettazione enterprise è come
			è comunque collegato a questi modelli di sviluppo. Tra l'altro l'ecosistema dei microservizi
			che è composto da svariati pattern di svilupo per componenti di rete come il pattern API gateway che
			fa da reverse proxy per la comunicazione client microservizi o il pattern API aggregator per 
			che serve a convogliare più microservizi insieme in un punto gateway appunto o il Pattern Proxy Gateway
			etc. sono fondamentalmente pattern di infrastrtuttura a livello enterprise ma che come modello
			di progettazione software interna si rifanno a questi pattern elementari in questo studio, e che
			formulano il contesto per le componentistiche enterprise dei microservizi e la loro comunicaizione.

	--- --- --- ----
	- Layered

	Questo articolo dà una spiegazione generale delle differenze e come si è arrivati
	con il tempo da applicazioni monolitiche ad applicazioni distribuite e più comunemente
	architetture moderne orgnizzate e distribuite per soluzioni web scalabili.
	https://learn.microsoft.com/it-it/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures

	Un articolo a parte
	https://hackernoon.com/from-n-tier-to-clean-architecture-with-net
	https://www.tutorialspoint.com/software_architecture_design/distributed_architecture.htm

	N-Layered

		Quando utilizzare questo Pattern e scopi.:

			Una progettazione Layered con N layer distribuiti per l'intera Architettura a compozione
			di un sistema enetrprise basato su più livelli applicativi e differenti per tipologia di
			viste e servizi. In questo esempio viene trattato un esempio completo sviluppato in ASP.NET
			4.5 una versione per la parte presentation in MVC 4 e un altro layer di presentazione 
			presentato in WebForms 4.5 e ancora un altro layer di presentazione usato da linea di 
			comando i layer per i Servizi sviluppati in WCF e ancora un altro layer interno per gli
			Unit Test con l'ausilio di Fluentassertions per rendere gli unit test più semplici da 
			scrivere e più facili da leggeree un altro indipendente per la configurazione del sistema 
			con DI tramite un framework conosciuto StrucutreMap e altre teconogie e framework 
			integrati come Automapper per i progetti di dominio w visualizzazione dei modelli in MVC, 
			DynamicQuery per le espressioni LINQ basate su stringhe e FileHelpers, una libreria 
			di terze parti per leggere i file CSV.
			Importante .:
			Si noti che c'è una grande differenza tra N-Layer e N-Tiers. 
			N-Layers si occupa di livelli software separati e consente di raggruppare il codice 
			in modo logico all'interno dell'applicazione. N-Tiers, d'altra parte, si occupa della 
			posizione fisica dei componenti software: ad esempio le macchine in cui viene eseguito 
			il codice. Questa serie di articoli si occupa esclusivamente di N-Layer, anche se è 
			possibile riutilizzarne gran parte anche in un'applicazione A più livelli.

	N-tier

		Quando utilizzare questo Pattern e scopi.:
	
			Nell'ingegneria del software, l'architettura multilivello (spesso indicata come 
			architettura a più livelli) è un'architettura client-server in cui le funzioni di 
			presentazione, elaborazione delle applicazioni e gestione dei dati sono fisicamente 
			separate. L'uso più diffuso dell'architettura multilivello è l'architettura a tre livelli.
			L'architettura dell'applicazione a più livelli fornisce un modello mediante il quale 
			gli sviluppatori possono creare applicazioni flessibili e riutilizzabili. 
			Separando un'applicazione in livelli, gli sviluppatori acquisiscono la possibilità 
			di modificare o aggiungere un livello specifico, invece di rielaborare l'intera 
			applicazione. Un'architettura a tre livelli è in genere composta da un livello di 
			presentazione, un livello logico e un livello dati.
			Mentre i concetti di livello e livello sono spesso usati in modo intercambiabile, 
			un punto di vista abbastanza comune è che c'è davvero una differenza. Questa vista 
			sostiene che un livello è un meccanismo di strutturazione logica per gli elementi 
			concettuali che compongono la soluzione software, mentre un livello è un meccanismo 
			di strutturazione fisica per gli elementi hardware che compongono l'infrastruttura 
			di sistema. Ad esempio, una soluzione a tre livelli potrebbe essere facilmente 
			implementata su un singolo livello, ad esempio nel caso di un'architettura estrema 
			incentrata sul database chiamata architettura solo RDBMS o in una workstation personale.
			Importante .:
			Si noti che c'è una grande differenza tra N-Layer e N-Tiers. 
			N-Layers si occupa di livelli software separati e consente di raggruppare il codice 
			in modo logico all'interno dell'applicazione. N-Tiers, d'altra parte, si occupa della 
			posizione fisica dei componenti software: ad esempio le macchine in cui viene eseguito 
			il codice. Questa serie di articoli si occupa esclusivamente di N-Layer, anche se è 
			possibile riutilizzarne gran parte anche in un'applicazione A più livelli.

	Hexagonal

		Quando utilizzare questo Pattern e scopi.:

			L'architettura esagonale, o architettura di porte e adattatori, è un modello architettonico 
			utilizzato nella progettazione di software. 
			Mira a creare componenti applicativi ad accoppiamento debole che possono essere facilmente 
			collegati al loro ambiente software per mezzo di porte e adattatori. 
			Ciò rende i componenti intercambiabili a qualsiasi livello e facilita l'automazione dei test.
			L'architettura esagonale è stata inventata da Alistair Cockburn nel tentativo di evitare 
			le insidie strutturali note nella progettazione di software orientato agli oggetti, 
			come dipendenze indesiderate tra i livelli e contaminazione del codice dell'interfaccia 
			utente con la logica di business, e pubblicato nel 2005. 
			Il termine "esagonale" deriva dalle convenzioni grafiche che mostrano il componente 
			applicativo come una cella esagonale. 
			Lo scopo non era quello di suggerire che ci sarebbero stati sei confini/porte, ma di 
			lasciare abbastanza spazio per rappresentare le diverse interfacce necessarie tra il 
			componente e il mondo esterno.

	Onion

			L'architettura Onion è una forma di architettura stratificata e possiamo visualizzare questi 
			livelli come cerchi concentrici. Da qui il nome Onion architecture. 
			L'architettura Onion è stata introdotta per la prima volta da Jeffrey Palermo, per 
			superare i problemi del tradizionale approccio architettonico a N strati.
			Ci sono diversi modi in cui possiamo dividere la stratificazione, ed è possibile 
			approcciare l'architettura dividendo l'architettura in quanti strati servono.
			Onion Architecture è un modello architettonico utilizzato nello sviluppo di software come un 
			modo per comunicare un approccio architettonico diverso. È un concetto di progettazione 
			orientato agli oggetti che enfatizza la separazione delle preoccupazioni quando si creano 
			applicazioni aziendali di lunga durata e applicazioni con comportamenti complessi. 
			L'architettura Onion elimina la dipendenza dai livelli che vengono sviluppati prima o dopo di essa.

	Clean

			L'architettura pulita è un'architettura software che ci aiuta a tenere sotto controllo un 
			intero codice applicativo. L'obiettivo principale dell'architettura pulita è il codice/logica,
			che è improbabile che cambi. Deve essere scritto senza alcuna dipendenza diretta. 
			Ciò significa che se voglio cambiare il mio framework di sviluppo OR User Interface (UI) 
			del sistema, il nucleo del sistema non deve essere modificato. 
			Significa anche che le nostre dipendenze esterne sono completamente sostituibili.
			La Clean Architecture ha un livello di dominio, un livello di applicazione, un livello 
			di infrastruttura e un livello di framework. 
			Il dominio e il livello dell'applicazione sono sempre il centro del progetto e sono noti come 
			il nucleo del sistema. Il nucleo sarà indipendente dall'accesso ai dati e dai problemi 
			infrastrutturali. Possiamo raggiungere questo obiettivo utilizzando le interfacce e 
			l'astrazione all'interno del sistema principale, ma implementandole al di fuori del 
			sistema principale.
			note.: Le applicazioni che osservano il principio DIP (Dependency Inversion Principle, 
			       principio di inversione delle dipendenze) e il principio DDD (Domain-Driven Design, 
				   progettazione basata su domini) tendono ad arrivare a un'architettura simile. 
				   Nel corso degli anni, questa architettura è stata indicata con molti nomi diversi. 
				   Uno dei primi nomi è stato Architettura Hexagonal, seguito da "Porte-e-adattatori". 
				   Più di recente, è stata indicata come Onion Architecture (Architettura ad anelli) 
				   o Clean Architecture (Architettura pulita).


	--- --- --- ----

	Service Locator

		Quando utilizzare questo Pattern e scopi.:
	
			Il modello di localizzazione del servizio è un modello di progettazione utilizzato 
			nello sviluppo del software per incapsulare i processi coinvolti nell'ottenimento 
			di un servizio con un forte livello di astrazione. Questo modello utilizza un 
			registro centrale noto come "service locator", che su richiesta restituisce le 
			informazioni necessarie per eseguire una determinata attività.
			I fautori del modello affermano che l'approccio semplifica le applicazioni basate 
			su componenti in cui tutte le dipendenze sono elencate in modo pulito all'inizio 
			dell'intera progettazione dell'applicazione, rendendo di conseguenza l'iniezione 
			di dipendenze tradizionale un modo più complesso di connettere gli oggetti. 
			I critici del modello sostengono che si tratta di un anti-modello che oscura le 
			dipendenze e rende il software più difficile da testare. 

	Inversion Of Control (IoC)

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come 


	---- ---- ----

	Active Record

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come 

	Identity Map

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come 

	Data Access Object (DAO)

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come 

	Data Transfer Object (DTO)

		Quando utilizzare questo Pattern e scopi.:
	
			Conosciuto come 

	---- ---- ----	
	



	
